# 测试
1. 测试源码文件的主名称应该以被测源码文件的主名称为前导，并且必须以“_test”为后缀
2. 对于功能测试函数来说，其名称必须以Test为前缀 （可以并发）
3. 性能测试函数以Benchmark为前缀 （不可以并发）

# 程序实体
xxx.(type)  只能用于switch语句

# GPM调度规则
G: goroutine ， 上下文切换开销小， go程序内部自己保存上下文，所以可以跨M切换
P: 用户级处理器,负责G与M建立联系
M: 系统级线程
P的数量默认等于GOMAXPROCES，每个P拥有一个本地队列， 每创建一个G就会放到一个本地队列中，如果都满了就会放到一个全局队列中，P与M绑定，M会从P的队列获取一个G，切换到这个G的栈开始执行，直到需要切。被停止执行的G会再次放到队列里，等待下一次被调度。M找不到G就会休眠
切换G的时机：
1. 阻塞io， M 和G都会进入iowaite状态，这个时候这个M会变得不可用， 与他绑定的P会寻找其他M，G肯定也就切换了。
2. G自己阻塞， select, channel满了的发送操作,channel空了的接收操作, 等待锁
3. G执行了10ms
4. 代码里主动切换 runtime.Gosched()

# 临时对象池
暂时不用的的对象放到对象池里， 用的时候再取出来，避免频繁的创建销毁对象，提高性能。GC友好，申请内存次数减少(并发安全) sync.pool, 结构体值类型


# range
表达式只会在for语句开始执行时被求值一次，无论后边会有多少次迭代；
range表达式的求值结果会被复制，也就是说，被迭代的对象是range表达式结果值的副本而不是原值。 引用类型才会被修改

# 继承与嵌套
golang 调用嵌套类型的方法实际是用嵌套的对象去调用的，本质还是组合， 嵌套类型是指针类型时，需要注意nil值不能调用值方法
值类型实现的方法指针类型默认实现， 指针类型实现值方法不一定实现
# 接口
接口有动态类型时，动态类型的值为nil时，接口不为nil
# GC
## 回收什么
1 三色标记清除
1.所有根节点可达的对象标记为灰色
2.扫描所有灰色对象，直接引用的所有对象标记为灰色，自身标记为黑色，重复这个步骤直到没有灰色对象，删除所有白色对象
用户进程的干扰，比如创建了一个对象被黑色对象引用，或者一个对象本来被灰色对象引用，然后转到被黑色对象引用，导致被错误删除

1.8之后混合写屏障
优先扫描栈，所有可达对象标记为黑色，新建的栈对象也会被标记为黑色，这就避免了栈上创建一个对象挂载黑色对象下被勿删的情况
GC期间堆上创建对象或者删除对象都会被标记为灰色，灰色表示待处理肯定会最终变为黑色
空间换时间， 为什么区别对待堆栈， 因为栈空间小要求响应速度快，所以要求GC迅速， 屏障机制也是用户程序通知GC程序的，所以减少通知次数

# 同步手段
锁，条件变量
原子操作
channel

# channel
传递的是副本，含函数传参一样，应该尽量传指针
发送接收都是原子性的，并发安全

# 控制goroutine数量
可以创建一个缓冲通道
，缓冲区大小就是goroutine上限，每创建goroutin前就像通道内发送一个空结构体，gouroutine运行完毕再从通道接收一个空结构体。
runtime.NumGoroutine() 查看goroutine 数量


# 字典
Go 语言字典的键类型不可以是函数类型、字典类型和切片类型。或者包含他们的高级类型, 他们只能和nil 比较
先把键转成哈希值，哈希值低八位定位到哈希桶，高8位定位键，找到对应的键，在比较键， 因为不同的键值的哈希值有可能相同， 利用哈希表，计算哈基值而不是遍历的方式的快速查找（O1），但是最终比对还是要比对键值
如果哈希碰撞严重复杂度会趋近O(n), 插入也是
sync.map 标准库的并发安全字典， 注意键类型的安全和普通字典一样

# array
和其他语言的数组一样，按下表查找是O(1),  其他查找是O(N),   切片新增元素如果扩容是O（n)

# 常用并发模型
1. 通过channel通知goroutine的退出
func main() {
    ch := make(chan struct{})
    go func() {
        fmt.Println("start working")
        time.Sleep(time.Second * 1)
        ch <- struct{}{}
    }()

    <-ch

    fmt.Println("finished")
}

2.waiteGroup  使用后不能再拷贝，主goroutine等待所有子goroutine完成

3. context 事先不知道多少子goroutine的时候用这个
cxt, cancelFunc := context.WithCancel(context.Background())
所有子goroutine结束的时候调用cancelFunc(),利用channel通知主gouruntine恢复运行

９、map如何顺序读取

map不能顺序读取，是因为他是无序的，想要有序读取，首先的解决的问题就是，把ｋｅｙ变为有序，所以可以把key放入切片，对切片进行排序，遍历切片，通过key取值。

１１、实现消息队列（多生产者，多消费者）

使用切片加锁可以实现， 解耦、异步、削峰
